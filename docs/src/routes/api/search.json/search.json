[
	{
		"title": "Getting Started",
		"href": "/docs/getting-started",
		"description": "A quick guide to get started using barqode",
		"content": "The following guide will walk you through installing and setting up the barqode components in your Svelte project.  Installation  Install the package using your preferred package manager:  npm install barqode  Basic Usage  The simplest way to use the library is with the BarqodeStream component for live scanning:    import { BarqodeStream, type DetectedBarcode } from \"barqode\";   function onDetect(detectedCodes: DetectedBarcode[]) {   console.log(detectedCodes.map((detectedCode) => detectedCode.rawValue));  }          .barqode {   width: 100%;   max-width: 600px;   aspect-ratio: 4/3;  }   For detailed information about each component's capabilities and options, refer to their respective API documentation pages."
	},
	{
		"title": "Introduction",
		"href": "/docs/index",
		"description": "What is Barqode?",
		"content": "Barqode provides a set of Svelte components for detecting and decoding QR codes and various other barcode formats right in the browser. It's a comprehensive solution that supports both camera streams and static image processing.  Barqode started out as a port of $2.  Components  BarqodeStream** - continuously scans frames from a camera stream. BarqodeDropzone** - drag & drop, click to upload or capture images from camera.  Features  Real-time scanning**. Detect codes from live camera stream. Multiple formats**. Support for QR codes and various barcode standards. Visual feedback**. Customizable canvas based tracking of detected codes. Cross-browser**. Works across modern browsers with a $2 if needed. Camera selection**. Choose between front/rear cameras. Torch control**. Control device flashlight where supported. Responsive**. Components adapt to fill available space. Error handling**. Comprehensive error handling for camera/detection issues.  Usage Example    import { BarqodeStream, type DetectedBarcode } from \"barqode\";   function onDetect(detectedCodes: DetectedBarcode[]) {   console.log(detectedCodes.map((detectedCode) => detectedCode.rawValue));  }          .barqode {   width: 100%;   max-width: 600px;   aspect-ratio: 4/3;  }  Browser Support  The components rely primarily on the $2 and $2, with fallbacks where possible.  While the core scanning functionality uses the native BarcodeDetector where available, it falls back to a $2 to ensure consistent behavior across browsers.  For a detailed compatibility overview, check each component's documentation."
	},
	{
		"title": "Full demo",
		"href": "/docs/demos/full-demo",
		"description": "Kitchen sink demo of the BarqodeStream component.",
		"content": "   import Demo from '$lib/components/demos/full-demo.svelte';   The BarqodeStream component continuously scans frames from a camera stream and detects barcodes in real-time.  Demo  Modern mobile phones often have a variety of different cameras installed (e.g. front, rear, wide-angle, infrared, desk-view). The one picked by default is sometimes not the best choice. For more fine-grained control, you can select a camera by device constraints or by the device ID.  Detected codes are visually highlighted in real-time. In this demo you can use the track function dropdown to change the flavor.  By default only QR-codes are detected but a variety of other barcode formats are also supported. You can select one or multiple but the more you select the more expensive scanning becomes.  Usage    import { BarqodeStream, type BarcodeFormat, type DetectedBarcode } from \"barqode\";   let result = $state(\"\");  let error = $state(\"\");   let selectedConstraints = $state({ facingMode: \"environment\" });   let barcodeFormats: {   [key in BarcodeFormat]: boolean;  } = $state({   aztec: false,   code_128: false,   code_39: false,   code_93: false,   codabar: false,   databar: false,   databar_expanded: false,   databar_limited: false,   data_matrix: false,   dx_film_edge: false,   ean_13: false,   ean_8: false,   itf: false,   maxi_code: false,   micro_qr_code: false,   pdf417: false,   qr_code: true,   rm_qr_code: false,   upc_a: false,   upc_e: false,   linear_codes: false,   matrix_codes: false,   unknown: false,  });   // computed value for selected formats  let selectedBarcodeFormats: BarcodeFormat[] = $derived(   Object.keys(barcodeFormats).filter(    (format: string) => barcodeFormats[format]   ) as BarcodeFormat[]  );   // track function options  const trackFunctionOptions = [   { text: \"nothing (default)\", value: undefined },   { text: \"outline\", value: paintOutline },   { text: \"centered text\", value: paintCenterText },   { text: \"bounding box\", value: paintBoundingBox },  ];   let trackFunctionSelected = $state(trackFunctionOptions[1]);   // camera constraint options  const defaultConstraintOptions: { label: string; constraints: MediaTrackConstraints }[] = [   { label: \"rear camera\", constraints: { facingMode: \"environment\" } },   { label: \"front camera\", constraints: { facingMode: \"user\" } },  ];   let constraintOptions = $state(defaultConstraintOptions);   async function onCameraOn() {   try {    const devices = await navigator.mediaDevices.enumerateDevices();    const videoDevices = devices.filter(({ kind }) => kind === \"videoinput\");     constraintOptions = [     ...defaultConstraintOptions,     ...videoDevices.map(({ deviceId, label }) => ({      label: ${label},      constraints: { deviceId },     })),    ];     error = \"\";   } catch (e) {    console.error(e);   }  }   function onError(err: { name: string; message: string }) {   error = [${err.name}]: ;    if (err.name === \"NotAllowedError\") {    error += \"you need to grant camera access permission\";   } else if (err.name === \"NotFoundError\") {    error += \"no camera on this device\";   } else if (err.name === \"NotSupportedError\") {    error += \"secure context required (HTTPS, localhost)\";   } else if (err.name === \"NotReadableError\") {    error += \"is the camera already in use?\";   } else if (err.name === \"OverconstrainedError\") {    error += \"installed cameras are not suitable\";   } else if (err.name === \"StreamApiNotSupportedError\") {    error += \"Stream API is not supported in this browser\";   } else {    error += err.message;   }  }   function onDetect(detectedCodes: DetectedBarcode[]) {   console.log(detectedCodes);   result = JSON.stringify(detectedCodes.map((code) => code.rawValue));  }   // track functions  function paintOutline(   detectedCodes: {    cornerPoints: { x: number; y: number }[];    boundingBox: DOMRectReadOnly;    rawValue: string;    format: Exclude;   }[],   ctx: CanvasRenderingContext2D  ) {   for (const detectedCode of detectedCodes) {    const [firstPoint, ...otherPoints] = detectedCode.cornerPoints;     ctx.strokeStyle = \"red\";    ctx.beginPath();    ctx.moveTo(firstPoint.x, firstPoint.y);     for (const { x, y } of otherPoints) {     ctx.lineTo(x, y);    }     ctx.lineTo(firstPoint.x, firstPoint.y);    ctx.closePath();    ctx.stroke();   }  }   function paintBoundingBox(   detectedCodes: {    cornerPoints: { x: number; y: number }[];    boundingBox: DOMRectReadOnly;    rawValue: string;    format: Exclude;   }[],   ctx: CanvasRenderingContext2D  ) {   for (const detectedCode of detectedCodes) {    const {     boundingBox: { x, y, width, height },    } = detectedCode;     ctx.lineWidth = 2;    ctx.strokeStyle = \"#007bff\";    ctx.strokeRect(x, y, width, height);   }  }   function paintCenterText(   detectedCodes: {    cornerPoints: { x: number; y: number }[];    boundingBox: DOMRectReadOnly;    rawValue: string;    format: Exclude;   }[],   ctx: CanvasRenderingContext2D  ) {   for (const detectedCode of detectedCodes) {    const { boundingBox, rawValue } = detectedCode;     const centerX = boundingBox.x + boundingBox.width / 2;    const centerY = boundingBox.y + boundingBox.height / 2;     const fontSize = Math.max(12, (50 * boundingBox.width) / ctx.canvas.width);     ctx.font = bold ${fontSize}px sans-serif;    ctx.textAlign = \"center\";     ctx.lineWidth = 3;    ctx.strokeStyle = \"#35495e\";    ctx.strokeText(detectedCode.rawValue, centerX, centerY);     ctx.fillStyle = \"#5cb984\";    ctx.fillText(rawValue, centerX, centerY);   }  }   Camera constraints:   {#each constraintOptions as option}       {option.label}     {/each}   Track function:   {#each trackFunctionOptions as option}       {option.text}     {/each}   Barcode formats:   {#each Object.keys(barcodeFormats) as option}   {@const barcodeOption = option as BarcodeFormat}           {option}     {/each}   {#if error}  {error} {/if}         Last result: {result}     .error {   font-weight: bold;   color: red;  }   .scanner {   width: 100%;   aspect-ratio: 4/3;  }  `"
	},
	{
		"title": "BarqodeDropzone",
		"href": "/docs/components/barqode-dropzone",
		"description": "Click to upload images, drag & drop or use your camera to scan.",
		"content": "   import Demo from '$lib/components/demos/barqode-dropzone.svelte';   This component functions as a file input with the capture attribute set to environment which allows users to take a picture with their camera. You can also drag-and-drop image files from your desktop or images embedded into other web pages anywhere in the area the component occupies. The images are directly scanned and positive results are indicated by the onDetect callback.  Demo  Usage    import { BarqodeDropzone, type DetectedBarcode } from \"barqode\";   let result = $state(\"\");  let dragover = $state(false);   function onDetect(detectedCodes: DetectedBarcode[]) {   result = detectedCodes.map((detectedCode) => detectedCode.rawValue).join(\", \");  }   function onDragover(isDraggingOver: boolean) {   dragover = isDraggingOver;  }            Click to upload or drop an image here        Last detected: {result}    .barqode {   width: 100%;   aspect-ratio: 4 / 3;   border: 2px solid #2563eb;  }   .dragover {   border-color: white;  }   .instructions {   height: 100%;   width: 100%;   display: flex;   justify-content: center;   align-items: center;  }  Props  formats  Type: [BarcodeFormat[]](https://github.com/Sec-ant/barcode-detector?tab=readme-ov-file#barcode-detector)  Default: [\"qr_code\"]  Configure the barcode formats to detect. By default, only QR codes are detected.  If you want to detect multiple formats, pass an array of formats:    Under the hood, the standard $2 is used. Support varies across devices, operating systems and browsers. All components will prefer to use the native implementation if available and otherwise falls back to a polyfill implementation.  Note that even if the native implementation is available, the component still might use the polyfill. For example, if the native implementation only supports the format 'qr_code' but the you select the formats ['qr_code', 'aztec'].  onDetect  Type: (detectedCodes: DetectedBarcode[]) => void  Callback function that is called when a barcode is detected.  It receives an array of $2, one callback per image.  If not barcode is detected, the array will be empty.  onDragover  Type: (isDraggingOver: boolean) => void  Callback function that is called when a file is dragged over the drop zone.  onError  Type: (error: Error) => void  Callback function that is called when an error occurs.  TODO: insert link to errors.  Other props  The BarqodeDropzone component accepts all attributes that a standard input element accepts.  By default, the following attributes are set:  type=\"file\". This is required to make the input a file input. You should not change this. name=\"image\". This is the name of the file input. accept=\"image/*\". This restricts the file types that can be uploaded to images. capture=\"environment\". This tells the browser to open the camera when the input is clicked on mobile devices. You can choose between user and environment, which opens the front and back camera respectively. You can also disable this functionality by setting it to null. multiple. This allows the user to upload multiple files at once. You can disable this by settings this to false.  Browser Support  This component depends on the $2 which is widely supported in modern browsers."
	},
	{
		"title": "BarqodeStream",
		"href": "/docs/components/barqode-stream",
		"description": "Continuously scans frames from a camera stream.",
		"content": "   import Demo from '$lib/components/demos/barqode-stream.svelte';   import { Callout } from '@svecodocs/kit';   The BarqodeStream component continuously scans frames from a camera stream and detects barcodes in real-time.  Demo  Usage    import { BarqodeStream, type DetectedBarcode } from \"barqode\";   let loading = $state(true);  let result: string | null = $state(null);   function onCameraOn() {   loading = false;  }   function onDetect(detectedCodes: DetectedBarcode[]) {   result = detectedCode.map((code) => detectedCode.rawValue).join(\", \");  }   function track(detectedCodes: DetectedBarcode[], ctx: CanvasRenderingContext2D) {   for (const detectedCode of detectedCodes) {    const [firstPoint, ...otherPoints] = detectedCode.cornerPoints;     ctx.strokeStyle = \"#2563eb\";    ctx.lineWidth = 2;    ctx.beginPath();    ctx.moveTo(firstPoint.x, firstPoint.y);     for (const { x, y } of otherPoints) {     ctx.lineTo(x, y);    }     ctx.lineTo(firstPoint.x, firstPoint.y);    ctx.closePath();    ctx.stroke();   }  }        {#if loading}    Loading...   {/if}     Last detected: {result}    .barqode {   width: 100%;   aspect-ratio: 4 / 3;  }   .loading-indicator {   width: 100%;   height: 100%;   display: flex;   justify-content: center;   align-items: center;   font-weight: bold;   font-size: 2rem;  }  Props  constraints  Type: $2  Default: { video: { facingMode: \"environment\" } }  Configure the the various camera options, for example whether to use front or rear camera.  The object must be of type MediaTrackConstraints.  The object is passed as-is to getUserMedia, which is the API call for requesting a camera stream:  navigator.mediaDevices.getUserMedia({  audio: false,  video: the_constraint_object_you_provide, });  When constraints is updated, a new camera stream is requested which triggers the onCameraOn callback again. You can catch errors with the onError callback. An error can occur when you try to use the front camera on a device that doesn't have one for example.  formats  Type: [BarcodeFormat[]](https://github.com/Sec-ant/barcode-detector?tab=readme-ov-file#barcode-detector)  Default: [\"qr_code\"]  Configure the barcode formats to detect. By default, only QR codes are detected.  If you want to detect multiple formats, pass an array of formats:      Don't select more barcode formats than needed.  Scanning becomes more expensive the more formats you select.    Under the hood, the standard $2 is used. Support varies across devices, operating systems and browsers. All components will prefer to use the native implementation if available and otherwise falls back to a polyfill implementation.  Note that even if the native implementation is available, the component still might use the polyfill. For example, if the native implementation only supports the format 'qr_code' but the you select the formats ['qr_code', 'aztec'].  paused  Type: boolean (bindable)  Default: false  Whether the camera stream is or should be paused. Bindable, which means that you can pause/unpause the stream from outside the component.  Pausing the stream by setting paused to true is useful if you want to show some microinteraction after successful scans. When the you set it to false, the camera stream will be restarted and the onCameraOn callback function will be triggered again.  torch  Type: boolean  Default: false  Turn the camera flashlight on or off.  This is not consistently supported by all devices and browsers. Support can even vary on the same device with the same browser. For example the rear camera often has a flashlight but the front camera does not.  We can only tell if flashlight control is supported once the camera is loaded and the onCameraOn callback has been called. At the moment, enabling the torch may silently fail on unsupported devices, but in the onCameraOn callback payload you can access the MediaTrackCapabilities object, from which you can determine if the torch is supported.  The camera stream must be reloaded when turning the torch on or off. That means the onCameraOn event will be emitted again.  track  Type: (detectedCodes: DetectedBarcode[], ctx: CanvasRenderingContext2D) => void  Callback function that can be used to visually highlight detected barcodes.  A transparent canvas is overlaid on top of the camera stream. The track function is used to draw on this canvas.  It receives an array of $2 and a $2 as the second argument.  Note that when track is set the scanning frequency has to be increased. So if you want to go easy on your target device you might not want to enable tracking.    The track function is called for every frame. It is important to keep the function as performant as possible.  This can lead to performance issues on low-end devices and memory leaks if not handled correctly.  onCameraOn  Type: (capabilities: MediaTrackCapabilities) => void  Callback function that is called when the camera stream is successfully loaded.  It might take a while before the component is ready and the scanning process starts. The user has to be asked for camera access permission first and the camera stream has to be loaded.  If you want to show a loading indicator, you can wait for this callback to be called. It is called as soon as the camera start streaming.  The callback receives the a promise which resolves with the cameras $2 when everything is ready.  onError  Type: (error: Error) => void  Callback function that is called when an error occurs.  TODO: insert link to errors.  onCameraOff  Type: () => void  Callback function that is called when the camera stream is stopped.  This can happen when the camera constraints are modified, for example when switching between front and rear camera or when turning the torch on or off.  onDetect  Type: (detectedCodes: DetectedBarcode[]) => void  Callback function that is called when a barcode is detected.  It receives an array of $2.    If you scan the same barcode multiple times in a row, onDetect is still only called once. When you hold a barcode in the camera, frames are actually decoded multiple times a second but you don't want to be flooded with callbacks that often. That's why the last decoded QR code is always cached and only new results are propagated. However, changing the value of paused resets this internal cache.  Browser Support  This component depends on the $2 which is widely supported in modern browsers."
	}
]
